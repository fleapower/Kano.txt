<!DOCTYPE html>
<html>
  <head>
    <style>
        
      body { font-family: Arial, sans-serif; }
      .task { cursor: pointer; padding: 5px; border-bottom: 1px solid #ccc; }
      .selected { background-color: #80EF80; }

      .header-bar {position: sticky; top: 0; background: white; padding: 10px; border-bottom: 1px solid #ccc;}
      .filter-bar {background: white; padding: 5px;}
      .context-bar {background: white; padding: 5px;}

      .button {
        font-size: 14px;
        font-weight: bold;
        border-radius: 8px;
      }

      .button:active {
        transform: translateY(2px);
        background-color: green;
      }

      .context-button {
        font-size: 14px;
        font-weight: bold;
        border-radius: 8px;
        margin: 2px;
      }

      .context-button:focus {
        border: 2px solid white;
        outline: 2px solid green;
      }

      .context-button.selected {
        background-color: green;
        color: white; 
      }
      .section {
        margin-bottom: 24px;
      }
      .section-title {
        font-weight: bold;
        color: #333;
        margin-bottom: 12px;
        font-size: 16px;
        border-bottom: 2px solid #eee;
        padding-bottom: 4px;
      }
      .shortcut-row {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
      }

      .priority-a {
        color: red;
      }
      .priority-b {
        color: orange;
      }
      .priority-c {
        color: green;
      }
      .priority-d {
        color: blue;
      }

      .context {
        font-family: monospace;
        color: #666;
        background-color: #f0f0f0;
        padding: 0 4px;
        border-radius: 3px;
      }
      .complete-task {
        text-decoration: line-through;
      }
      .overdue-task {
        color: red;
      }
      .task {
        -webkit-user-select: none;  /* Safari */
        -ms-user-select: none;      /* IE 10 and IE 11 */
        user-select: none;          /* Standard syntax */
      }


      .sidebar-dialog {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        width: 90%;
        max-width: 900px;
        height: auto;
        max-height: 90vh;
        background: white;
        padding: 30px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        border-radius: 8px;
        transition: transform 0.3s ease;
      }

      .sidebar-dialog.active {
        transform: translate(-50%, -50%) scale(1);
      }

      .sidebar-dialog input {
        width: 100%;
        padding: 8px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-family: Arial, sans-serif;
        font-size: 16px;
      }

      .sidebar-dialog textarea {
        width: 100%;
        padding: 8px;
        margin: 10px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-family: Arial, sans-serif;
        font-size: 16px;
        height: 150px;
        min-height: 150px;
        resize: vertical;
      }

      .sidebar-dialog .buttons {
        bottom: 20px;
        width: calc(100% - 40px);
      }

      .sidebar-dialog button {
        padding: 8px 16px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      .sidebar-dialog .confirm {
        background-color: gray;
        color: white;
      }

      .sidebar-dialog .cancel {
        background-color: gray;
        color: white;
      }

      .confirm {
        background-color: #4CAF50;
        color: white;
        padding: 8px 24px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
      }

      .confirm:hover {
        background-color: #45a049;
      }

      .calendar {
        width: 280px;
        border: 1px solid #ccc;
        padding: 8px;
        margin: 10px 0;
      }

      .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .calendar-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 2px;
      }

      .weekdays {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        text-align: center;
        font-weight: bold;
        margin-bottom: 4px;
      }

      .week {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
      }

      .day {
        padding: 4px;
        text-align: center;
        cursor: pointer;
      }

      .day:hover {
        background-color: #e0e0e0;
      }

      .empty {
        padding: 4px;
      }

      .file-date {
        color: #666;
      }

      .file-browser {
        max-height: 300px;
        overflow-y: auto;
        margin: 10px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .file-item {
        padding: 10px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-item:hover {
        background-color: #f5f5f5;
      }

      .file-item.selected {
        background-color: #e3f2fd;
      }

      .file-name {
        font-weight: bold;
      }

      .file-info {
        font-size: 0.9em;
        color: #666;
      }
    </style>
    <base target="_top">
  </head>
  <body tabindex="0">
    <h1>Kano.txt
    <button class="button" onclick="loadNewFile()">Load ToDo.txt file</button>
    </h1>
    <div id="dialogContainer"></div>
    <div id="headerContainer" class="header-bar">
      <div class="filter-bar">
        <button class="button" id="completeButton" onclick="cycleCompleteState()">All States</button>
        <button class="button" id="dueButton" onclick="cycleDueState()">All Dates</button>
        <button class="button" id="priorityButton" onclick="cyclePriorityState()">All Pri</button>
        <button class="button" id="sortButton" onclick="cycleSortState()">Sort: File</button>
        <button class="button" onclick="clearFilters()">Clear Filters</button>
        <input type="text" id="searchBox" placeholder="Find..." oninput="applyFilters()">

        <script>
          const searchBox = document.getElementById('searchBox');
          
          searchBox.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
              searchBox.value = '';
              searchBox.blur();
              applyFilters(); // Optional: Call applyFilters to clear filters when the search box is cleared
            }
          });
        </script>
      </div>
      <div id="contextButtons" class="context-bar">
      </div>
    </div>
    <div id="taskList"></div>
    <script>
      
      let allTasks = [];
      let lastModifiedTime = null;
      let lastSavedTime = null;
      let lastSelectedIndex = -1;
      let selectedTasks = new Set();
      let activeContexts = new Set();
      let filteredTasks = [];
      let dueState = "All Dates";
      let priorityState = "All Pri";
      let completeState = "All States";  // Can be "All States", "Complete", or "Pending"
      let currentSortState = 'file'; // Can be 'file', 'date', or 'priority'
      let validPriorities = [];
      let cutTasks = [];

      const saveTimeout = 3000; // You can increase this if you are getting an error that too many scripts are running on your account.  This is in milliseconds.

      function getNextDayOfWeekDate(dayOfWeek) {
        const daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const today = new Date();
        const todayDayOfWeek = today.getDay();
        const targetDayOfWeek = daysOfWeek.findIndex(day => day.toLowerCase() === dayOfWeek.toLowerCase());
        const daysUntilNext = (targetDayOfWeek + 7 - todayDayOfWeek) % 7 || 7;
        today.setDate(today.getDate() + daysUntilNext);
        return today.toLocaleDateString('en-CA');
      }

      // Function to replace due date keywords with actual dates in user's local time zone
      function replaceDueDateKeywords(task) {
        return task.replace(/due:today/gi, `due:${getTodayDate()}`)
                  .replace(/due:tomorrow/gi, `due:${getTomorrowDate()}`)
                  .replace(/due:(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/gi, (match, day) => `due:${getNextDayOfWeekDate(day)}`);
      }

      function toggleCompletion(selectedTasks) {
        const todayDate = getTodayDate();
        selectedTasks.forEach(task => {
          if (task.Task.startsWith('x ')) {
            task.Task = task.Task.replace(/^x \d{4}-\d{2}-\d{2} /, '');
          } else {
            task.Task = `x ${todayDate} ${task.Task}`;
          }
        });
      }

      function editTask(index) {
        const task = allTasks[index];
        const htmlContent = `
          <h2>Edit Task</h2>
          <textarea autofocus>${task.Task}</textarea>
          <div id="calendar"></div>
          <div class="buttons">
            <button class="confirm">Save</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        
        showDialog(htmlContent, (newTask) => {
          if (newTask !== null) {
            allTasks[index].Task = replaceDueDateKeywords(newTask);
            updateValidPriorities(); // Add this line
            applyFilters();
          }
        });

        // Position cursor at end
        setTimeout(() => {
          const textarea = document.querySelector('.sidebar-dialog textarea');
          textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
        }, 50);
      }

      function addNewTask() {
        const htmlContent = `
          <h2>New Task</h2>
          <textarea placeholder="Enter the new task" autofocus>(</textarea>
          <div id="calendar"></div>
          <div class="buttons">
            <button class="confirm">Add</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        
        showDialog(htmlContent, (newTask) => {
          if (newTask) {
            allTasks.unshift({ TaskID: allTasks.length, Task: replaceDueDateKeywords(newTask) });
            updateValidPriorities(); // Add this line
            applyFilters();
          }
        });

        // Position cursor after (
        setTimeout(() => {
          const textarea = document.querySelector('.sidebar-dialog textarea');
          textarea.selectionStart = textarea.selectionEnd = 1;
        }, 50);
      }

      function setDateForSelectedTasks() {
        const htmlContent = `
          <h2>Set Due Date</h2>
          <input type="text" placeholder="Enter the new date (YYYY-MM-DD, today, tomorrow, or day of the week)">
          <div id="calendar"></div>
          <div class="buttons">
            <button class="confirm">Set Date</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        
        showDialog(htmlContent, (newDate) => {
          if (newDate) {
            const originalIndices = getOriginalIndices();
            const formattedDate = replaceDueDateKeywords(`due:${newDate}`).split('due:')[1];
            originalIndices.forEach(index => {
              const task = allTasks[index];
              if (task.Task.includes('due:')) {
                allTasks[index].Task = task.Task.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${formattedDate}`);
              } else {
                allTasks[index].Task = `${task.Task} due:${formattedDate}`;
              }
            });
            applyFilters();
          }
        });

        // Initialize calendar after dialog content is rendered
        const calendarContainer = document.querySelector('#calendar');
        if (calendarContainer) {
          setTimeout(() => {
            const calendar = new Calendar(calendarContainer, {
              onChange: (date) => {
                const input = document.querySelector('.sidebar-dialog input');
                if (input) {
                  input.value = date;
                }
              }
            });
          }, 0);
        }
      }

      function deleteTask(index) {
        const task = allTasks[index];
        const htmlContent = `
          <h2>Delete Task(s)</h2>
          <input type=hidden value="delete">
          <p>Are you sure?</p>
          <div class="buttons">
            <button class="confirm" data-confirmed="true">Delete</button>
            <button class="cancel" data-confirmed="false">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (confirmed) => {
          if (confirmed) {
            const originalIndices = getOriginalIndices().sort((a, b) => b - a);
            originalIndices.forEach(idx => {
              allTasks.splice(idx, 1);
            });
            updateValidPriorities(); // Add this line
            applyFilters();
          }
        });
      }

      function changePriority(tasks, increase) {
        tasks.forEach(task => {
          const currentPriority = extractPriority(task.Task);
          if (!currentPriority) return;
          
          const currentIndex = validPriorities.indexOf(currentPriority);
          if (currentIndex === -1) return;
          
          const newIndex = increase ? 
            Math.max(0, currentIndex - 1) : 
            Math.min(validPriorities.length - 1, currentIndex + 1);
          
          task.Task = task.Task.replace(/\([A-I]\)/, `(${validPriorities[newIndex]})`);
        });
      }

      function setPriorityForSelectedTasks() {
        const htmlContent = `
          <h2>Set Priority</h2>
          <input type="text" 
                placeholder="(A, B, C...)" 
                maxlength="1" 
                pattern="[A-Za-z]"
                onkeydown="return /[a-zA-Z]/i.test(event.key) || event.key === 'Backspace' || event.key === 'Delete' || event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'Tab'"
                style="text-transform: uppercase;">
          <div class="buttons">
            <button class="confirm">Set Priority</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (newPriority) => {
          if (newPriority && /^[A-Za-z]$/.test(newPriority)) {
            const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              const currentPriority = extractPriority(allTasks[index].Task);
              if (currentPriority) {
                allTasks[index].Task = allTasks[index].Task.replace(/\([A-D]\)/, `(${newPriority.toUpperCase()})`);
              } else {
                allTasks[index].Task = `(${newPriority.toUpperCase()}) ${allTasks[index].Task}`;
              }
            });
            applyFilters();
          }
        });
      }

      // Function to postpone selected tasks
      function postponeSelectedTasks() {
        const htmlContent = `
        <h2>Delay</h2>
        <input type="number" placeholder="Enter the number of days to delay task">
        <div class="buttons">
            <button class="confirm">Delay</button>
            <button class="cancel">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, (days) => {
          if (days) {
			      const originalIndices = getOriginalIndices();
            originalIndices.forEach(index => {
              const task = allTasks[index];
              const dueDateMatch = task.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
              if (dueDateMatch) {
                const dueDate = new Date(dueDateMatch[1]);
                dueDate.setDate(dueDate.getDate() + parseInt(days));
                const newDueDate = dueDate.toISOString().split('T')[0];
                allTasks[index].Task = task.Task.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${newDueDate}`);
              }
            });
            applyFilters();
          }
        });
      }

      function saveFilterSet(number) {
        const filterSet = {
          dueState: dueState,
          priorityState: priorityState,
          completeState: completeState,
          searchQuery: document.getElementById('searchBox').value,
          activeContexts: Array.from(activeContexts)
        };
        allFilterSets[number] = filterSet;  // Save to memory
        
        // Save all filter sets to a single file
        google.script.run.saveAllFilterSets(allFilterSets);
        
        const htmlContent = `
          <h2>Filter set saved.</h2>
          <input type="hidden" value="copy">
          <div class="buttons">
            <button class="confirm" autofocus>OK</button>
            <button class="cancel" style="display: none;">Cancel</button>
          </div>
        `;
        showDialog(htmlContent, () => {});
      }

      function loadFilterSet(number) {
        const filterSet = allFilterSets[number];
        if (filterSet) {
          applyLoadedFilterSet(filterSet);
        }
      }
      
      function cyclePriorityState() {
        updateValidPriorities(); // Update priorities before cycling
        const states = ["All Pri", ...validPriorities.map(p => `(${p})`)];
        const currentIndex = states.indexOf(priorityState);
        priorityState = states[(currentIndex + 1) % states.length];
        document.getElementById('priorityButton').textContent = priorityState;
        applyFilters();
      }

      function cycleCompleteState() {
        const states = ["All States", "Pending", "Complete"];  // Swapped Pending and Complete
        completeState = states[(states.indexOf(completeState) + 1) % 3];
        document.getElementById('completeButton').textContent = completeState;
        applyFilters();
      }

      function cycleDueState() {
        const states = ["All Dates", "Due Today", "Due Tomorrow"];
        dueState = states[(states.indexOf(dueState) + 1) % 3];
        document.getElementById('dueButton').textContent = dueState;
        applyFilters();
      }

      function updateValidPriorities() {
        const priorities = new Set();
        allTasks.forEach(task => {
          const match = task.Task.match(/\(([A-Z])\)/);
          if (match) priorities.add(match[1]);
        });
        validPriorities = Array.from(priorities).sort();
        
        // Update the priority button options
        const priorityButton = document.getElementById('priorityButton');
        if (priorityButton) {
          const currentState = priorityButton.textContent;
          if (!["All Pri", ...validPriorities.map(p => `(${p})`)].includes(currentState)) {
            priorityButton.textContent = "All Pri";
            priorityState = "All Pri";
          }
        }
      }

      function toggleContextFilter(context) {
        const button = document.querySelector(`.context-button[data-context="${context}"]`);
        if (activeContexts.has(context)) {
          activeContexts.delete(context);
          button.classList.remove('selected');
        } else {
          activeContexts.add(context);
          button.classList.add('selected');
        }
        applyFilters();
      }

      function applySearchFilter(taskText, searchTerms) {
        if (!searchTerms.length) return true;
        
        const lowerTaskText = taskText.toLowerCase();
        
        // Handle exclusions first
        const excludedTerms = searchTerms
          .filter(term => term.startsWith('-'))
          .map(term => term.slice(1).toLowerCase());
        
        if (excludedTerms.some(term => lowerTaskText.includes(term))) {
          return false;
        }
        
        // Remove exclusions from further processing
        const remainingTerms = searchTerms.filter(term => !term.startsWith('-'));
        
        // If no terms left after exclusions, return true
        if (!remainingTerms.length) return true;
        
        // Separate AND groups and regular terms
        const andGroups = [];
        const regularTerms = [];
        
        let currentGroup = [];
        let inGroup = false;
        
        remainingTerms.forEach(term => {
          if (term.startsWith('[')) {
            inGroup = true;
            // Remove '[' and add the rest of the term
            currentGroup.push(term.slice(1).toLowerCase());
          } else if (term.endsWith(']')) {
            inGroup = false;
            // Remove ']' and add the rest of the term
            currentGroup.push(term.slice(0, -1).toLowerCase());
            andGroups.push([...currentGroup]);
            currentGroup = [];
          } else if (inGroup) {
            currentGroup.push(term.toLowerCase());
          } else {
            regularTerms.push(term.toLowerCase());
          }
        });
        
        // A match occurs if either:
        // 1. Any of the regular terms match OR
        // 2. Any of the AND groups have all their terms match
        return regularTerms.some(term => lowerTaskText.includes(term)) ||
              andGroups.some(group => group.every(term => lowerTaskText.includes(term)));
      }

      function cycleSortState() {
        const sortButton = document.getElementById('sortButton');
        
        switch (currentSortState) {
          case 'file':
            sortTasksByDueDate();
            sortButton.textContent = 'Sort: Date';
            currentSortState='date';
            displaySortedTasks();
            break;
          case 'date':
            sortTasksByPriority();
            sortButton.textContent = 'Sort: Priority';
            currentSortState='priority';
            displaySortedTasks();
            break;
          case 'priority':
            currentSortState = 'file';
            sortButton.textContent = 'Sort: File';
            currentSortState='file';
            applyFilters();
            break;
        }
      }

      function sortTasksByDueDate() {
        
        // Create a new sorted array instead of modifying allTasks
        filteredTasks.sort((a, b) => {
          const aDate = a.task.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
          const bDate = b.task.Task.match(/due:(\d{4}-\d{2}-\d{2})/);
          return (aDate ? new Date(aDate[1]) : new Date(0)) - (bDate ? new Date(bDate[1]) : new Date(0));
        });
        
        // Refresh the display without saving
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
      }

      function sortTasksByPriority() {
        
        // Create a new sorted array instead of modifying allTasks
        filteredTasks.sort((a, b) => {
          const prioA = extractPriority(a.task.Task);
          const prioB = extractPriority(b.task.Task);
          
          if (!prioA && !prioB) return 0;
          if (!prioA) return 1;
          if (!prioB) return -1;
          
          return prioA.localeCompare(prioB);
        });
        
        // Refresh the display without saving
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
      }

      function copySelectedTasks() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const selectedText = Array.from(selectedTasks)
          .sort((a, b) => a - b)
          .map(index => tasks[index].textContent)
          .join('\n');
		    navigator.clipboard.writeText(selectedText);
      }

      function applyLoadedFilterSet(filterSet) {
        clearFilters();
        dueState = filterSet.dueState || "All Dates";
        priorityState = filterSet.priorityState || "All Pri";
        completeState = filterSet.completeState || "All States";
        activeContexts = new Set(filterSet.activeContexts);
        
        document.getElementById('dueButton').textContent = dueState;
        document.getElementById('priorityButton').textContent = priorityState;
        document.getElementById('completeButton').textContent = completeState;
        document.getElementById('searchBox').value = filterSet.searchQuery;
        
        // Update context button states to match loaded filter
        const contextButtons = document.getElementsByClassName('context-button');
        Array.from(contextButtons).forEach(button => {
          if (activeContexts.has(button.dataset.context)) {
            button.classList.add('selected');
          }
        });
        
        applyFilters();
      }

      function clearFilters() {
        dueState = "All Dates";
        priorityState = "All Pri";
        completeState = "All States";
        currentSortState = "file";
        document.getElementById('dueButton').textContent = "All Dates";
        document.getElementById('priorityButton').textContent = "All Pri";
        document.getElementById('completeButton').textContent = "All States";
        document.getElementById('sortButton').textContent = "Sort: File";
        document.getElementById('searchBox').value = '';
        const contextButtons = document.getElementsByClassName('context-button');
        Array.from(contextButtons).forEach(button => {
          button.classList.remove('selected');
        });
        activeContexts.clear();
        applyFilters();
      }

      function loadTasks() {
        google.script.run
          .withSuccessHandler(function(result) {
            lastModifiedTime = result.lastModified;
            lastSavedTime = result.lastModified;
            displayTasks(result.tasks);
          })
          .getTasksAndModifiedTime();
      }

      function displayTasks(tasks) {
        allTasks = tasks;
        generateContextButtons();
        applyFilters();
      }
  
      function updateTaskCount() {
      const taskList = document.getElementById('taskList');
      const counter = document.createElement('div');
      counter.style.cssText = 'position: fixed; bottom: 10px; right: 10px; padding: 5px; border: 1px solid #ccc; background: white;';
      counter.textContent = `${filteredTasks.length}/${allTasks.length}`;
      taskList.appendChild(counter);
      }

      function generateContextButtons() {
        const contextButtons = document.getElementById('contextButtons');
        const contexts = new Set();
        allTasks.forEach(task => {
          const match = task.Task.match(/ @\w+/g);
          if (match) {
            match.forEach(context => contexts.add(context.trim()));
          }
        });
        contextButtons.innerHTML = '';

        // Add "No Lists" button
        const noContextsButton = document.createElement('button');
        noContextsButton.className = 'context-button';
        noContextsButton.textContent = 'No Lists';
        noContextsButton.dataset.context = 'No Lists';
        noContextsButton.onclick = () => toggleContextFilter('No Lists');
        contextButtons.appendChild(noContextsButton);

        Array.from(contexts).sort().forEach(context => {
          const button = document.createElement('button');
          button.className = 'context-button';
          button.textContent = context;
          button.dataset.context = context;
          button.onclick = () => toggleContextFilter(context);
          contextButtons.appendChild(button);
        });
      }

      // Helper function to extract priority from task text
      function extractPriority(taskText) {
        const match = taskText.match(/\(([A-I])\)/);
        return match ? match[1] : null;
      }

      function displaySortedTasks() {
        switch (currentSortState) {
          case 'date':
            sortTasksByDueDate();
            break;
          case 'priority':
            sortTasksByPriority();
            break;
          default:
            break;
        }
        const taskList = document.getElementById('taskList');
        taskList.innerHTML = '';
        
        filteredTasks.forEach(({ task, originalIndex }, filteredIndex) => {
          const div = document.createElement('div');
          div.className = 'task';
          div.dataset.taskId = task.TaskID;
          div.dataset.originalIndex = originalIndex;
          div.dataset.filteredIndex = filteredIndex;
          div.onclick = (event) => handleTaskClick(event, filteredIndex);

          // Task display formatting
          let taskText = task.Task
            .replace(/\(A\)/g, '<span class="priority-a">(A)</span>')
            .replace(/\(B\)/g, '<span class="priority-b">(B)</span>')
            .replace(/\(C\)/g, '<span class="priority-c">(C)</span>')
            .replace(/\(D\)/g, '<span class="priority-d">(D)</span>')
            .replace(/\b([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\b/g, function(match) {
              return `<a href="mailto:${match}" target="_blank">${match}</a>`;
            })
            .replace(/\b(https?:\/\/\S+)/gi, '<a href="$1" target="_blank">$1</a>')
            .replace(/\b(due:\S+)\b/g, '<span class="context">$1</span>')
            .replace(/([+]\S+)/g, '<span class="context">$1</span>')
            .replace(/\b(r:\S+)\b/g, '<span class="context">$1</span>')
            .replace(/\b(last:\S+)\b/g, '<span class="context">$1</span>')
            .replace(/(\s@\S+)\b/g, '<span class="context">$1</span>');

          const dueDate = taskText.substring(taskText.indexOf('due:') + 4, taskText.indexOf('due:') + 14);
          const today = getTodayDate();
          if (dueDate < today) {
            taskText = `<span class="overdue-task">${taskText}</span>`;
          }

          if (task.Task.startsWith('x ')) {
            taskText = `<span class="complete-task">${taskText}</span>`;
          }

          div.innerHTML = taskText;
          taskList.appendChild(div);
        });

        updateTaskCount();

        if (lastSelectedIndex === -1 && taskList.children.length > 0) {
          const firstTask = taskList.children[0];
          firstTask.classList.add('selected');
          selectedTasks.clear();
          selectedTasks.add(0);
          lastSelectedIndex = 0;
        }

      }

      function applyFilters() {
        /*
        if (currentSortState !== 'file') {
          currentSortState = 'file';
        }
        */

        updateValidPriorities(); // update in case they have been changed
        
        const searchBox = document.getElementById('searchBox');
        const searchQuery = searchBox.value;
        
        // Split search terms while preserving quoted strings and AND groups
        const searchTerms = searchQuery.match(/(?:[^\s"]+|"[^"]*")+/g) || [''];
        
        filteredTasks = allTasks
          .map((task, originalIndex) => ({ task, originalIndex }))
          .filter(({ task }) => {
            const taskText = task.Task;
            const dueDate = taskText.match(/due:(\d{4}-\d{2}-\d{2})/)?.[1] || '';
            const today = getTodayDate();
            const tomorrow = getTomorrowDate();
            const isComplete = taskText.startsWith('x ');
            const taskPriority = extractPriority(taskText);
            
            const matchesDue = dueState === "All Dates" || 
              (dueState === "Due Today" && dueDate <= today) ||
              (dueState === "Due Tomorrow" && dueDate === tomorrow);
            
            const matchesComplete = completeState === "All States" ||
              (completeState === "Complete" && isComplete) ||
              (completeState === "Pending" && !isComplete);
            
            const matchesPriority = priorityState === "All Pri" || 
              (taskPriority && `(${taskPriority})` === priorityState);
            
            const matchesContexts = Array.from(activeContexts).length === 0 || Array.from(activeContexts).some(context => {
              if (context === 'No Lists') return !taskText.match(/ @\w+/);
              return taskText.includes(context);
            });

            // Use the advanced search filter functionality
            const matchesSearch = applySearchFilter(taskText, searchTerms);
            
            return matchesDue && matchesComplete && matchesSearch && matchesPriority && matchesContexts;
          });

        // Display the filtered (and possibly sorted) tasks
        displaySortedTasks();
      }

      function swapTasks(filteredIndex1, filteredIndex2) {
        if (currentSortState !== 'file') {
          // Don't allow swapping when sorted
          return;
        }
        // Get the original indices from the filtered tasks
        const originalIndex1 = filteredTasks[filteredIndex1].originalIndex;
        const originalIndex2 = filteredTasks[filteredIndex2].originalIndex;

        // Swap in the allTasks array
        const tempTask = allTasks[originalIndex1];
        allTasks[originalIndex1] = allTasks[originalIndex2];
        allTasks[originalIndex2] = tempTask;

        // Update TaskIDs
        allTasks[originalIndex1].TaskID = originalIndex1;
        allTasks[originalIndex2].TaskID = originalIndex2;

        // Instead of rebuilding everything, directly swap the DOM elements
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const task1 = tasks[filteredIndex1];
        const task2 = tasks[filteredIndex2];
        
        // Cache the task height before any DOM changes
        const taskHeight = task1.offsetHeight;
        
        // Create a temporary marker for task2's position
        const temp = document.createElement('div');
        task2.parentNode.insertBefore(temp, task2);
        
        // Perform the DOM swap
        task1.parentNode.insertBefore(task2, task1);
        temp.parentNode.insertBefore(task1, temp);
        temp.parentNode.removeChild(temp);
        
        // Update selection - keep the original selected task highlighted as it moves
        Array.from(tasks).forEach(task => task.classList.remove('selected'));
        task1.classList.add('selected');
        selectedTasks.clear();
        selectedTasks.add(filteredIndex2);
        lastSelectedIndex = filteredIndex2;

        // Update filteredTasks array to match DOM
        filteredTasks[filteredIndex1] = { task: allTasks[originalIndex1], originalIndex: originalIndex1 };
        filteredTasks[filteredIndex2] = { task: allTasks[originalIndex2], originalIndex: originalIndex2 };
        
        // Calculate scroll position based on cached task height
        const rect = task1.getBoundingClientRect();
        const tasksFromTop = Math.floor(rect.top / taskHeight);
        const tasksFromBottom = Math.floor((window.innerHeight - rect.bottom) / taskHeight);
        
        // Only scroll if necessary
        if (tasksFromTop < 5) {
          window.scrollBy({
            top: -((5 - tasksFromTop) * taskHeight),
            behavior: 'instant'
          });
        } else if (tasksFromBottom < 5) {
          window.scrollBy({
            top: ((5 - tasksFromBottom) * taskHeight),
            behavior: 'instant'
          });
        }
        
        // Store the task text that should remain selected after refresh
        const selectedTaskText = task1.textContent;
        
        // Debounce the full refresh to run after user stops moving tasks
        clearTimeout(window.refreshTimeout);
        window.refreshTimeout = setTimeout(() => {
          applyFilters();
          // After refresh, find and reselect the task
          const newTaskList = document.getElementById('taskList');
          const newTasks = newTaskList.getElementsByClassName('task');
          for (let i = 0; i < newTasks.length; i++) {
            if (newTasks[i].textContent === selectedTaskText) {
              newTasks[i].classList.add('selected');
              selectedTasks.clear();
              selectedTasks.add(i);
              lastSelectedIndex = i;
              break;
            }
          }
        }, 500);
      }

      // Function to get today's date in user's local time zone in YYYY-MM-DD format
      function getTodayDate() {
        const today = new Date();
        return today.toLocaleDateString('en-CA'); // 'en-CA' locale for YYYY-MM-DD format
      }

      // Function to get tomorrow's date in user's local time zone in YYYY-MM-DD format
      function getTomorrowDate() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return tomorrow.toLocaleDateString('en-CA');
      }

      class Calendar {
        constructor(container, options = {}) {
          this.container = container;
          this.onChange = options.onChange || (() => {});
          this.selectedDate = null;
          this.currentDate = new Date();
          this.today = new Date().toISOString().split('T')[0]; // Store today's date in YYYY-MM-DD format
          this.render();
        }

        render() {
          const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"];
          
          const calendar = document.createElement('div');
          calendar.className = 'calendar';
          
          // Header with month/year and navigation
          const header = document.createElement('div');
          header.className = 'calendar-header';
          header.innerHTML = `
            <button class="prev-month">&lt;</button>
            <span>${monthNames[this.currentDate.getMonth()]} ${this.currentDate.getFullYear()}</span>
            <button class="next-month">&gt;</button>
          `;
          
          calendar.appendChild(header);
          
          // Calendar grid
          const grid = document.createElement('div');
          grid.className = 'calendar-grid';

          // Days of week header
          const daysOfWeek = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
          daysOfWeek.forEach(day => {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'calendar-day';
            dayDiv.textContent = day;
            grid.appendChild(dayDiv);
          });
          
          const firstDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), 1);
          const lastDay = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth() + 1, 0);
          const startingDay = firstDay.getDay();
          
          // Add empty cells for days before the first of the month
          for (let i = 0; i < startingDay; i++) {
            const emptyDay = document.createElement('div');
            emptyDay.className = 'calendar-day empty';
            grid.appendChild(emptyDay);
          }
          
          // Add days of the month
          for (let day = 1; day <= lastDay.getDate(); day++) {
            const dayDiv = document.createElement('div');
            dayDiv.className = 'calendar-day';
            dayDiv.textContent = day;
            
            const date = new Date(this.currentDate.getFullYear(), this.currentDate.getMonth(), day);
            const dateString = date.toISOString().split('T')[0];
            dayDiv.dataset.date = dateString;
            
            // Add today highlight
            if (dateString === this.today) {
              dayDiv.classList.add('today');
              dayDiv.style.backgroundColor = '#90EE90'; // Light green background
              dayDiv.style.fontWeight = 'bold';
            }
            
            if (this.selectedDate === dateString) {
              dayDiv.classList.add('selected');
            }
            
            dayDiv.addEventListener('click', () => {
              const oldSelected = grid.querySelector('.selected');
              if (oldSelected) oldSelected.classList.remove('selected');
              
              dayDiv.classList.add('selected');
              this.selectedDate = dayDiv.dataset.date;
              this.onChange(this.selectedDate);
            });
            
            grid.appendChild(dayDiv);
          }
          
          calendar.appendChild(grid);
          
          // Event listeners for navigation
          header.querySelector('.prev-month').addEventListener('click', () => {
            this.currentDate.setMonth(this.currentDate.getMonth() - 1);
            this.render();
          });
          
          header.querySelector('.next-month').addEventListener('click', () => {
            this.currentDate.setMonth(this.currentDate.getMonth() + 1);
            this.render();
          });
          
          // Replace existing calendar if any
          this.container.innerHTML = '';
          this.container.appendChild(calendar);
        }
      }

      function initCalendar(container) {
        const calendar = document.createElement('div');
        calendar.className = 'calendar';
        container.appendChild(calendar);
        
        const date = new Date();
        const currentMonth = date.getMonth();
        const currentYear = date.getFullYear();
        
        const monthNames = ["January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"];
          
        calendar.innerHTML = `
          <div class="calendar-header">
            <button class="prev-month">&lt;</button>
            <span>${monthNames[currentMonth]} ${currentYear}</span>
            <button class="next-month">&gt;</button>
          </div>
          <div class="calendar-grid">
            ${generateCalendarDays(currentYear, currentMonth)}
          </div>
        `;
        
        // Add event listeners for navigation and date selection
        const prevButton = calendar.querySelector('.prev-month');
        const nextButton = calendar.querySelector('.next-month');
        
        prevButton.addEventListener('click', () => {
          date.setMonth(date.getMonth() - 1);
          updateCalendar(calendar, date);
        });
        
        nextButton.addEventListener('click', () => {
          date.setMonth(date.getMonth() + 1);
          updateCalendar(calendar, date);
        });
        
        return calendar;
      }

      function generateCalendarDays(year, month) {
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const startDay = firstDay.getDay();
        const daysInMonth = lastDay.getDate();
        
        let html = '<div class="weekdays">Su Mo Tu We Th Fr Sa</div>';
        let day = 1;
        
        for (let i = 0; i < 6; i++) {
          html += '<div class="week">';
          for (let j = 0; j < 7; j++) {
            if ((i === 0 && j < startDay) || day > daysInMonth) {
              html += '<span class="empty"></span>';
            } else {
              html += `<span class="day" data-date="${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}">${day}</span>`;
              day++;
            }
          }
          html += '</div>';
          if (day > daysInMonth) break;
        }
        
        return html;
      }

      function updateCalendar(calendar, date) {
        const monthNames = ["January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"];
        
        calendar.querySelector('.calendar-header span').textContent = 
          `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        
        calendar.querySelector('.calendar-grid').innerHTML = 
          generateCalendarDays(date.getFullYear(), date.getMonth());
      }


      function showDialog(htmlContent, callback) {
        const dialogContainer = document.getElementById('dialogContainer');
        dialogContainer.innerHTML = `
          <div class="sidebar-dialog">
            ${htmlContent}
          </div>
        `;
          
        const dialog = dialogContainer.querySelector('.sidebar-dialog');
        setTimeout(() => dialog.classList.add('active'), 10);

        const closeDialog = () => {
          dialog.classList.remove('active');
          setTimeout(() => {
            callback(null);
            dialogContainer.innerHTML = '';
            document.removeEventListener('click', handleOutsideClick);
            document.removeEventListener('keydown', handleEscapeKey);
          }, 300);
        };

        const handleOutsideClick = (e) => {
          // Prevent closing if clicking calendar navigation buttons
          if (e.target.classList.contains('prev-month') || 
              e.target.classList.contains('next-month')) {
            e.stopPropagation();
            return;
          }
          
          if (!dialog.contains(e.target)) {
            closeDialog();
          }
        };

        const handleEscapeKey = (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            closeDialog();
          }
        };

        // Focus priority: visible input/textarea first, then confirm button
        const input = dialog.querySelector('input:not([type="hidden"]), textarea');
        const confirmButton = dialog.querySelector('.confirm');

        if (input && window.getComputedStyle(input).display !== 'none') {
          // Delay focus slightly to ensure the dialog is fully rendered
          setTimeout(() => {
            input.focus();
            if (input.tagName.toLowerCase() === 'input') {
              input.select(); // Select all text in input fields
            }
          }, 50);

          input.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
              e.preventDefault();
              closeDialog();
              return;
            }
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              dialog.classList.remove('active');
              setTimeout(() => {
                callback(input.value);
                dialogContainer.innerHTML = '';
                document.removeEventListener('click', handleOutsideClick);
                document.removeEventListener('keydown', handleEscapeKey);
              }, 300);
            }
          });
        } else if (confirmButton) {
          // If no input or hidden input, focus the confirm button
          setTimeout(() => confirmButton.focus(), 50);
        }

        if (confirmButton) {
          confirmButton.onclick = () => {
            dialog.classList.remove('active');
            setTimeout(() => {
              const inputElement = dialog.querySelector('input, textarea');
              const value = inputElement && inputElement.type !== 'hidden' ? inputElement.value : true;
              callback(value);
              dialogContainer.innerHTML = '';
              document.removeEventListener('click', handleOutsideClick);
              document.removeEventListener('keydown', handleEscapeKey);
            }, 300);
          };
        }

        const cancelButton = dialog.querySelector('.cancel');
        if (cancelButton) {
          cancelButton.onclick = closeDialog;
        }

        // Initialize calendar after dialog content is rendered
        const calendarContainer = dialog.querySelector('#calendar');
        if (calendarContainer) {
          // Wait for DOM to be fully rendered
          setTimeout(() => {
            const calendar = new Calendar(calendarContainer, {
              onChange: (date) => {
                const textarea = dialog.querySelector('textarea');
                if (textarea) {
                  const cursorPos = textarea.selectionStart;
                  const textBefore = textarea.value.substring(0, cursorPos);
                  const textAfter = textarea.value.substring(textarea.selectionEnd);
                  
                  // Check if there's already a due date
                  const dueDate = textarea.value.match(/due:\d{4}-\d{2}-\d{2}/);
                  if (dueDate) {
                    textarea.value = textarea.value.replace(/due:\d{4}-\d{2}-\d{2}/, `due:${date}`);
                  } else {
                    textarea.value = textBefore + ` due:${date} ` + textAfter;
                  }
                  
                  textarea.focus();
                }
              }
            });
          }, 0);
        }

        // Add event listeners after a short delay
        setTimeout(() => {
          document.addEventListener('click', handleOutsideClick);
          document.addEventListener('keydown', handleEscapeKey);
        }, 100);
      }

      function getOriginalIndices() {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        return Array.from(selectedTasks).map(index => parseInt(tasks[index].dataset.originalIndex));
      }

      function checkFileModified() {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(function(currentModifiedTime) {
              if (currentModifiedTime !== lastModifiedTime) {
                const htmlContent = `
                  <h2>Warning: File Modified</h2>
                  <p>The task file has been modified externally since it was last loaded.</p>
                  <p>Do you want to:</p>
                  <div class="buttons">
                    <button class="confirm">Save Anyway</button>
                    <button class="cancel" autofocus>Cancel Save (tasks will be reloaded)</button>
                  </div>
                `;
                showDialog(htmlContent, (confirmed) => {
                  resolve(confirmed === null ? false : true);
                });
              } else {
                resolve(true);
              }
            })
            .withFailureHandler(function(error) {
              reject(error);
            })
            .getLastModifiedTime();
        });
      }

      // Function to save all tasks to a text file
      async function saveTasks() {
        try {
          const canSave = await checkFileModified();
          if (canSave) {
            const allTasksText = allTasks.map(task => task.Task).join('\n');
            google.script.run
              .withSuccessHandler(function(newModifiedTime) {
                lastModifiedTime = newModifiedTime;
                lastSavedTime = newModifiedTime;
              })
              .saveTasksToFile(allTasksText);
          } else {
            // Optionally reload the file here if user cancels
            loadTasks();
          }
        } catch (error) {
          const htmlContent = `
            <h2>Error</h2>
            <p>Failed to check file status: ${error}</p>
            <div class="buttons">
              <button class="confirm">OK</button>
              <button class="cancel" style="display: none;">Cancel</button>
            </div>
          `;
          showDialog(htmlContent, () => {});
        }
      }
      function loadNewFile() {
        const dialogContent = `
          <h2>Loading Files...</h2>
          <p>Searching for todo files in your Google Drive...</p>
        `;
        
        showDialog(dialogContent, null);
        
        google.script.run
          .withSuccessHandler((files) => {
            const fileList = files && files.length > 0 ? files.map(file => `
              <div class="file-item" data-id="${file.id}">
                <span class="file-name">${file.name}</span>
                <span class="file-info">
                  Modified: ${new Date(file.date).toLocaleString()}
                  (${(file.size / 1024).toFixed(1)} KB)
                </span>
              </div>
            `).join('') : '';
            
            const htmlContent = `
              <h2>Todo Files</h2>
              ${files && files.length > 0 ? `
                <p>Select an existing todo file or create a new one:</p>
                <div class="file-browser">
                  ${fileList}
                </div>
              ` : `
                <p>No existing todo files found.</p>
              `}
              <div class="new-file-section">
                <button class="button new-file-button">Create New Todo File</button>
              </div>
              <div class="buttons">
                ${files && files.length > 0 ? `
                  <button class="confirm" disabled>Select File</button>
                ` : ''}
                <button class="cancel">Cancel</button>
              </div>
            `;

            const handleFileCreation = () => {
              const createFileContent = `
                <h2>Create New Todo File</h2>
                <input type="text" 
                      placeholder="Enter file name (e.g., todo.txt)" 
                      value="todo.txt"
                      pattern=".+\\.txt$">
                <p class="input-hint">File name must end with .txt</p>
                <div class="buttons">
                  <button class="confirm">Create</button>
                  <button class="cancel">Cancel</button>
                </div>
              `;

              showDialog(createFileContent, (fileName) => {
                if (fileName) {
                  if (!fileName.toLowerCase().endsWith('.txt')) {
                    fileName += '.txt';
                  }

                  const loadingContent = `
                    <h2>Creating File...</h2>
                    <p>Please wait while we set up your new todo file.</p>
                  `;
                  showDialog(loadingContent, null);

                  google.script.run
                    .withSuccessHandler((fileId) => {
                      if (fileId) {
                        // First set up the file ID
                        google.script.run
                          .withSuccessHandler((success) => {
                            if (success) {
                              const successContent = `
                                <h2>File Created</h2>
                                <p>Your new todo file has been created and set up.</p>
                                <p>Please press CTRL-R to refresh the to-do list.</p>
                                <div class="buttons">
                                  <button class="confirm" autofocus>OK</button>
                                </div>
                              `;
                              showDialog(successContent, () => {
                                setTimeout(() => {
                                  window.top.location.reload();
                                }, 100);
                              });
                            } else {
                              const errorContent = `
                                <h2>Error</h2>
                                <p>Failed to set up the new file.</p>
                                <div class="buttons">
                                  <button class="confirm" autofocus>OK</button>
                                </div>
                              `;
                              showDialog(errorContent, () => {});
                            }
                          })
                          .withFailureHandler((error) => {
                            const errorContent = `
                              <h2>Error</h2>
                              <p>Failed to set up file: ${error}</p>
                              <div class="buttons">
                                <button class="confirm" autofocus>OK</button>
                              </div>
                            `;
                            showDialog(errorContent, () => {});
                          })
                          .setupFileId(fileId);
                      } else {
                        const errorContent = `
                          <h2>Error</h2>
                          <p>Failed to create the new file.</p>
                          <div class="buttons">
                            <button class="confirm" autofocus>OK</button>
                          </div>
                        `;
                        showDialog(errorContent, () => {});
                      }
                    })
                    .withFailureHandler((error) => {
                      const errorContent = `
                        <h2>Error</h2>
                        <p>Failed to create file: ${error}</p>
                        <div class="buttons">
                          <button class="confirm" autofocus>OK</button>
                        </div>
                      `;
                      showDialog(errorContent, () => {});
                    })
                    .createNewTodoFile(fileName);
                }
              });
            };
                  
            // Single function to handle file selection
            const handleFileSelection = (fileId) => {
              const loadingContent = `
                <h2>Loading File...</h2>
                <p>Please wait while we set up your todo file.</p>
              `;
              showDialog(loadingContent, null);
              
              google.script.run
                .withSuccessHandler((success) => {
                  if (success) {
                    const successContent = `
                      <h2>File Loaded</h2>
                      <p>Please press CTRL-R to refresh the to-do list.</p>
                      <div class="buttons">
                        <button class="confirm" autofocus>OK</button>
                      </div>
                    `;
                    showDialog(successContent, () => {
                      setTimeout(() => {
                        window.top.location.reload();
                      }, 100);
                    });
                  } else {
                    const errorContent = `
                      <h2>Error</h2>
                      <p>Failed to load the selected file.</p>
                      <div class="buttons">
                        <button class="confirm" autofocus>OK</button>
                      </div>
                    `;
                    showDialog(errorContent, () => {});
                  }
                })
                .withFailureHandler((error) => {
                  const errorContent = `
                    <h2>Error</h2>
                    <p>Failed to set up file: ${error}</p>
                    <div class="buttons">
                      <button class="confirm" autofocus>OK</button>
                    </div>
                  `;
                  showDialog(errorContent, () => {});
                })
                .setupFileId(fileId);
            };
            
            showDialog(htmlContent, () => {});

            // Get dialog elements after the dialog is shown
            const dialog = document.querySelector('.sidebar-dialog');
            const fileItems = dialog.querySelectorAll('.file-item');
            const confirmButton = dialog.querySelector('.confirm');
            const newFileButton = dialog.querySelector('.new-file-button');
            let selectedFileId = null;

            // Add click handlers for file selection
            fileItems.forEach(item => {
              item.addEventListener('click', () => {
                fileItems.forEach(f => f.classList.remove('selected'));
                item.classList.add('selected');
                selectedFileId = item.dataset.id;
                if (confirmButton) confirmButton.disabled = false;
              });

              item.addEventListener('dblclick', () => {
                if (item.dataset.id) {
                  handleFileSelection(item.dataset.id);
                }
              });
            });

            // Add click handler for new file button
            if (newFileButton) {
              newFileButton.addEventListener('click', handleFileCreation);
            }

            // Update confirm button handler
            if (confirmButton) {
              confirmButton.onclick = () => {
                if (selectedFileId) {
                  handleFileSelection(selectedFileId);
                }
              };
            }
          })
          .withFailureHandler((error) => {
            const errorContent = `
              <h2>Error</h2>
              <p>Failed to list todo files: ${error}</p>
              <div class="buttons">
                <button class="confirm" autofocus>OK</button>
              </div>
            `;
            showDialog(errorContent, () => {});
          })
          .listTodoFiles();
      }

       // automatically save waiting for 'saveTimeout' milliseconds
      let timeoutId;
      // Function to listen for keyboard input
      function listenForKeyboardInput() {
        document.addEventListener('keydown', resetTimer);
      }
      // Function to reset the timer
      function resetTimer() {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(saveTasks, saveTimeout);
      }

      function handleTaskClick(event, index) {
        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        const originalIndex = parseInt(tasks[index].dataset.originalIndex);

        if (event.detail === 2) {
          editTask(originalIndex);
        } else {
          if (event.ctrlKey) {
            tasks[index].classList.toggle('selected');
            if (selectedTasks.has(index)) {
              selectedTasks.delete(index);
            } else {
              selectedTasks.add(index);
            }
          } else if (event.shiftKey && lastSelectedIndex !== -1) {
            const start = Math.min(lastSelectedIndex, index);
            const end = Math.max(lastSelectedIndex, index);
            for (let i = start; i <= end; i++) {
              tasks[i].classList.add('selected');
              selectedTasks.add(i);
            }
          } else {
            Array.from(tasks).forEach(task => task.classList.remove('selected'));
            tasks[index].classList.add('selected');
            selectedTasks.clear();
            selectedTasks.add(index);
          }
          lastSelectedIndex = index;
        }
      }

      function handleKeyDown(event) {
        if (currentSortState !== 'file' && 
            ((event.ctrlKey && (event.key === 'ArrowUp' || event.key === 'ArrowDown')) ||
            (event.ctrlKey && (event.key.toLowerCase() === 'x' || event.key.toLowerCase() === 'v')))) {
          return;
        }
        
        if (document.activeElement === document.getElementById('searchBox') || 
            document.getElementById('dialogContainer').innerHTML !== '') {
          return;
        }

        const taskList = document.getElementById('taskList');
        const tasks = taskList.getElementsByClassName('task');
        
        if (lastSelectedIndex === -1) return;

        if (event.ctrlKey && event.key.toLowerCase() === 'x') {
          event.preventDefault();
          // Get all selected task indices in reverse order (to remove from end to start)
          const originalIndices = getOriginalIndices().sort((a, b) => b - a);
          
          // Clear previous cut tasks
          cutTasks = [];
          
          // Store the tasks that are being cut in original order
          originalIndices.reverse().forEach(index => {
            cutTasks.push({...allTasks[index]});
          });
          
          // Remove the cut tasks from allTasks (still in reverse order for proper splicing)
          originalIndices.forEach(index => {
            allTasks.splice(index, 1);
          });
          
          // Update display
          applyFilters();
        }

        if (event.ctrlKey && event.key.toLowerCase() === 'v') {
          event.preventDefault();
          
          if (cutTasks.length > 0) {
            // Get the current selected task's original index
            let insertIndex;
            if (lastSelectedIndex >= 0 && lastSelectedIndex < filteredTasks.length) {
              insertIndex = filteredTasks[lastSelectedIndex].originalIndex; // Insert before current selection
            } else {
              insertIndex = allTasks.length; // If no selection, append to end
            }
            
            // Insert all cut tasks at the insertion point in original order
            cutTasks.forEach((task) => {
              allTasks.splice(insertIndex++, 0, {...task});
            });
            
            // Reapply filters to update the display
            applyFilters();
          }
        }        

        if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          const selectedTask = tasks[lastSelectedIndex];
          
          if (selectedTask) {
            const rect = selectedTask.getBoundingClientRect();
            const viewHeight = window.innerHeight;
            
            // Get distance from top/bottom of viewport in number of tasks
            const tasksFromTop = Math.floor(rect.top / rect.height);
            const tasksFromBottom = Math.floor((viewHeight - rect.bottom) / rect.height);
            
            // Only prevent default scrolling if we're not near the edges
            if (event.key === 'ArrowUp' && tasksFromTop > 5 || 
                event.key === 'ArrowDown' && tasksFromBottom > 5) {
              event.preventDefault();
            }
          }

          if (event.key === 'ArrowUp') {
            if (event.ctrlKey && lastSelectedIndex > 0) {
              swapTasks(lastSelectedIndex, lastSelectedIndex - 1);
            } else if (event.altKey) {
              const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
              changePriority(selectedTaskObjects, true);
              applyFilters();
              const taskList = document.getElementById('taskList');
              const tasks = taskList.getElementsByClassName('task');
              selectedTasks.forEach(index => {
                tasks[index].classList.add('selected');
              });
            } else if (lastSelectedIndex > 0) {
              if (event.shiftKey) {
                // If shift is pressed, toggle selection of the previous task
                const newIndex = lastSelectedIndex - 1;
                if (selectedTasks.has(newIndex)) {
                  tasks[lastSelectedIndex].classList.remove('selected');
                  selectedTasks.delete(lastSelectedIndex);
                } else {
                  tasks[newIndex].classList.add('selected');
                  selectedTasks.add(newIndex);
                }
                lastSelectedIndex = newIndex;
              } else {
                // If no shift, clear all selections and select only the new task
                Array.from(tasks).forEach(task => task.classList.remove('selected'));
                lastSelectedIndex--;
                tasks[lastSelectedIndex].classList.add('selected');
                selectedTasks.clear();
                selectedTasks.add(lastSelectedIndex);
              }
            }
          } else if (event.key === 'ArrowDown') {
            if (event.ctrlKey && lastSelectedIndex < tasks.length - 1) {
              swapTasks(lastSelectedIndex, lastSelectedIndex + 1);
            } else if (event.altKey) {
              const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
              changePriority(selectedTaskObjects, false);
              applyFilters();
              const taskList = document.getElementById('taskList');
              const tasks = taskList.getElementsByClassName('task');
              selectedTasks.forEach(index => {
                tasks[index].classList.add('selected');
              });
            } else if (lastSelectedIndex < tasks.length - 1) {
              if (event.shiftKey) {
                // If shift is pressed, toggle selection of the next task
                const newIndex = lastSelectedIndex + 1;
                if (selectedTasks.has(newIndex)) {
                  tasks[lastSelectedIndex].classList.remove('selected');
                  selectedTasks.delete(lastSelectedIndex);
                } else {
                  tasks[newIndex].classList.add('selected');
                  selectedTasks.add(newIndex);
                }
                lastSelectedIndex = newIndex;
              } else {
                // If no shift, clear all selections and select only the new task
                Array.from(tasks).forEach(task => task.classList.remove('selected'));
                lastSelectedIndex++;
                tasks[lastSelectedIndex].classList.add('selected');
                selectedTasks.clear();
                selectedTasks.add(lastSelectedIndex);
              }
            }
          }
        } else if (event.key === ' ') {
          event.preventDefault();
          const selectedTask = tasks[lastSelectedIndex];
          if (selectedTask) {
            const originalIndex = parseInt(selectedTask.dataset.originalIndex);
            editTask(originalIndex);
          }
        } else if (event.ctrlKey && event.key.toLowerCase() ==='a') {
          event.preventDefault();
          const tasks = document.getElementsByClassName('task');
          Array.from(tasks).forEach((task, index) => {
            task.classList.add('selected');
            selectedTasks.add(index);
          });
          lastSelectedIndex = tasks.length - 1;
        } else if (event.key.toLowerCase() ==='c' && event.ctrlKey) {
          copySelectedTasks();
        } else if (event.key.toLowerCase() ==='c' && !event.ctrlKey) {
          cycleCompleteState();
        } else if (event.ctrlKey && event.altKey && event.key >= '1' && event.key <= '9') {
          saveFilterSet(event.key);
        } else if (event.key >= '1' && event.key <= '9') {
          loadFilterSet(event.key);
        } else if (!event.ctrlKey && event.key.toLowerCase() ==='x') {
          const selectedTaskObjects = getOriginalIndices().map(i => allTasks[i]);
          toggleCompletion(selectedTaskObjects);
          applyFilters();
          const taskList = document.getElementById('taskList');
          const tasks = taskList.getElementsByClassName('task');
          selectedTasks.forEach(index => {
            tasks[index].classList.add('selected');
          });
        } else if (event.key === 'Delete') {
          event.preventDefault();
          deleteTask(filteredTasks[lastSelectedIndex].originalIndex);
        } else if (!event.ctrlKey && event.key.toLowerCase() ==='f') {
          event.preventDefault();
          document.getElementById('searchBox').focus();
          return;
        } else if (event.key === '?') {
          event.preventDefault();
          showHelpWindow();
        } else if (event.key === '(') {
          addNewTask();
        } else if (event.key.toLowerCase() === 'q') {
          event.preventDefault();
          cyclePriorityState();
        } else if (event.key.toLowerCase() ==='s') {
          event.preventDefault();
          setDateForSelectedTasks();
        } else if (event.key.toLowerCase() ==='t') {
          event.preventDefault();
          cycleSortState();
        } else if (event.key.toLowerCase() ==='p') {
          event.preventDefault();
          setPriorityForSelectedTasks();
        } else if (event.key.toLowerCase() ==='d') {
          event.preventDefault();
          postponeSelectedTasks();
        } else if (event.key.toLowerCase() ==='u') {
          event.preventDefault();
          cycleDueState();
        } else if (event.key.toLowerCase() ==='0') {
          event.preventDefault();
          clearFilters();
        }
      }

      function showHelpWindow() {
        // Use google.script.run to call the server-side function
        google.script.run
          .withSuccessHandler(function(helpContent) {
            const htmlContent = `
              <div class="help-content">
                ${helpContent}
              </div>
            `;
            showDialog(htmlContent, () => {});
          })
          .withFailureHandler(function(error) {
            alert('Failed to load help content. Please try again.');
          })
          .getHelpContent();
      }

      // Start listening for keyboard input
      listenForKeyboardInput();

	    // Add this line to focus the page on load
	    window.onload = () => document.body.focus();

      document.addEventListener('DOMContentLoaded', function() {
        google.script.run
          .withSuccessHandler(function(result) {
            lastModifiedTime = result.lastModified;
            lastSavedTime = result.lastModified;
            
            // Store tasks but don't display them yet
            allTasks = result.tasks;
            generateContextButtons();
            
            // Load filter sets and then display tasks
            google.script.run
              .withSuccessHandler(function(filterSets) {
                allFilterSets = filterSets || {};
                if (filterSets['1']) {
                  loadFilterSet('1');  // This will trigger applyFilters()
                } else {
                  // If no filter set 1, then apply default display
                  applyFilters();
                }
              })
              .getAllFilterSets();
          })
          .getTasksAndModifiedTime();
      });

      document.addEventListener('keydown', handleKeyDown);    
	  
	    // Add this line to focus the page on load
	    window.onload = () => document.body.focus();

    </script>
  </body>
</html>